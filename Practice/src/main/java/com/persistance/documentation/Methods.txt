For the sake of keeping my code clean, all the notes about method creation and 
what each line does will be found in this file.


###############################################################################
	
	@Autowired // This means to get the bean called userRepository
		   // Which is auto-generated by Spring, we will use it to handle the data
		   // this will take care of persistence
	private UserRepository userRepository;
//	
//	@GetMapping("/")
//	// when the GET HTTP request for the index is called, it creates a user
//	// object saved in a Model object's String as attribute that can receive the
//	// arguments of the object and pass them as attributes to the destination.
//	// Great for form handling
//    public String registerForm21(Model model) {
//        model.addAttribute("users", new Users());// will bind the input fields of the form to the users object
//        model.addAttribute("role", new Role());
//        return "index";
//    }
//	
//	@PostMapping(path="/add") // Map ONLY POST Requests... @GetMapping does the opposite
//	public /*@ResponseBody*/ String addNewUser21 (@RequestParam String username
//		, @RequestParam String email, @RequestParam String password,
//		// @RequestParam means it is a parameter from the GET or POST request
//		@ModelAttribute Users user) {
//	// @ResponseBody means the returned String is the response, not a view name
//	
//	//////////////////////////
//	Role role1 = new Role("USER");
//	List<Role> roles = new ArrayList<>();
//	roles.add(role1);
//	//////////////////////////
//	
//	Users user1 = new Users();
//	user1.setActive(1);
//	user1.setEmail(email);
//	user1.setUsername(username);
//	user1.setPassword(password);
//	//////////////////////////
//	user1.setRoles(roles);
//	//////////////////////////
	/*this will also persist the role because of the cascade = CascadeType.ALL which
	 * update all the classes referenced in the current class*/ 
//	userRepository.save(user1);
//	return "saved";
//	}
//
//	@GetMapping(path="/all")
//	public @ResponseBody Iterable<Users> getAllUsers21() {
//	// This returns a JSON or XML with the users
//	return userRepository.findAll();
//	}
//	
//	@PreAuthorize("hasAnyRole('ADMIN')") /*method level authorization; enabled 
//	in security file through the @EnableGlobalMethodSecurity*/
//	@GetMapping(path="/secured/all")
//	public @ResponseBody String getAllUsers221() {
//	// This returns a JSON or XML with the users
//	
//	return "ONLY ADMINS CAN SEE THIS PAGE... YOU ARE AN ADMIN!!";
//	}
#######################################################################################################################
	// method to insert user for registration
	public void createUser(Users user) {
		
// this is a password encryption tool provided by SPRING security that generates a random key every time
		BCryptPasswordEncoder encoder =  new BCryptPasswordEncoder();
// when saving the password in the DB we will save in encrypted format 
		user.setPassword(encoder.encode(user.getPassword()));
		
		Role userRole = new Role("USER"); //spring security expects a role table to enable the authorization features
		List<Role> roles = new ArrayList<>();// there is a list of Role objects in the Users class... create new list
		roles.add(userRole);// ad the new role inside the list of Roles in user object
		user.setRoles(roles); //setting the role in the list of Roles
		
		userRepository.save(user);/*this will also persist the role because of the 
		cascade = CascadeType.ALL which update all the classes referenced in the current class...
		By persisting the Role and Users info at the same time... the joinTable 
		will also be updated as it uses info from the Role and Users table */
		
	}
#################################################################################################################

	public Users findOne(String email) {
		// receives a String argument containing an email and looks for it in the DB through the repository
		return userRepository.findOne(email);
	}
	
//
//}
